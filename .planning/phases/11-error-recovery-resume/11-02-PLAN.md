---
phase: 11-error-recovery-resume
plan: 02
type: tdd
domain: go-cli
---

<objective>
Extend lifecycle executor to save state on failure and support resuming from saved state.

Purpose: Allow workflows that fail mid-lifecycle to be resumed from the failure point.
Output: Updated executor with state persistence and resume capability.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-error-recovery-resume/11-01-SUMMARY.md
@internal/lifecycle/executor.go
@internal/state/state.go

**Dependencies:**

- 11-01 provides: state.State, state.Save, state.Load, state.Clear, state.Exists, state.ErrNoState

**Design decisions:**

- Executor gets new StateManager interface for testability
- On workflow failure: save state with step index of failed step, then return error
- On success: clear state file (if exists)
- New ExecuteWithResume function that loads state and resumes from step index
- Validate state matches current story (story key matches)
- Validate state matches current lifecycle (total steps and start status)
  </context>

<feature>
  <name>Executor Resume Support</name>
  <files>internal/lifecycle/executor.go, internal/lifecycle/executor_test.go</files>
  <behavior>
    New StateManager interface:
    - Save(state state.State) error
    - Load() (state.State, error)
    - Clear() error

    Modified Execute behavior:
    - On workflow failure: save state before returning error
    - On success (all workflows complete): clear state

    New ExecuteWithResume(ctx, storyKey string) error:
    - Load saved state
    - If state.ErrNoState: run normal Execute (no resume needed)
    - If state exists but story key doesn't match: return error (stale state)
    - If state exists and matches: resume from state.StepIndex
    - Same failure/success state handling as Execute

    Cases:
    - Execute saves state on workflow failure (step index = failed step)
    - Execute clears state on successful completion
    - ExecuteWithResume with no saved state runs normal Execute
    - ExecuteWithResume resumes from saved step index
    - ExecuteWithResume with mismatched story key returns error
    - ExecuteWithResume clears state after successful completion
    - ExecuteWithResume saves new state on second failure
    - State validation: total steps and start status must match

  </behavior>
  <implementation>
    - Add StateManager interface to executor.go
    - Add stateManager field to Executor struct (optional - nil means no state tracking)
    - NewExecutorWithState constructor for state-enabled executor
    - Modify Execute to save/clear state via stateManager (if set)
    - ExecuteWithResume: load state, validate, call executeFromStep
    - Extract executeFromStep(ctx, storyKey, steps, startIndex) for reuse
  </implementation>
</feature>

<verification>
go test ./internal/lifecycle/... -v
</verification>

<success_criteria>

- All tests pass
- Execute saves state on failure
- Execute clears state on success
- ExecuteWithResume resumes from saved step
- Stale state (wrong story) detected and rejected
  </success_criteria>

<output>
After completion, create `.planning/phases/11-error-recovery-resume/11-02-SUMMARY.md`:

# Phase 11 Plan 02: Executor Resume Support Summary

**[One-liner describing what shipped]**

## Performance

- Duration: X min
- TDD Phases: RED, GREEN, REFACTOR (if any)

## RED Phase

[What tests were written, why they failed]

## GREEN Phase

[What implementation made them pass]

## REFACTOR Phase (if any)

[What cleanup was done]

## Files Created/Modified

- `internal/lifecycle/executor.go` - StateManager interface, ExecuteWithResume, state handling
- `internal/lifecycle/executor_test.go` - Resume tests, mock StateManager

## Decisions Made

[Any decisions during implementation]

## Issues Encountered

[Any issues and resolutions]

## Next Phase Readiness

[Ready for 11-03: CLI --resume flag]
</output>
