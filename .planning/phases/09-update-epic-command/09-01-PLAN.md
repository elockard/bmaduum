---
phase: 09-update-epic-command
plan: 01
type: tdd
domain: go-cli
---

<objective>
Update epic command to execute full lifecycle per story using lifecycle.Executor.

Purpose: Epic should complete each story (create→dev→review→commit→done) before moving to next, not just run one workflow per story.
Output: Epic command runs full lifecycle for each story in sequence.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (from frontmatter dependency graph):

@.planning/phases/07-story-lifecycle-executor/07-02-SUMMARY.md
@.planning/phases/08-update-run-command/08-01-SUMMARY.md

# Key files:

@internal/cli/epic.go
@internal/cli/epic_test.go
@internal/cli/run.go
@internal/cli/run_test.go
@internal/lifecycle/executor.go
@internal/workflow/queue.go

**Tech stack available:**

- lifecycle.Executor for orchestrating full story workflows
- lifecycle.WorkflowRunner, StatusReader, StatusWriter interfaces
- Table-driven tests with mock implementations

**Established patterns:**

- Interface-based DI in App struct for testability
- lifecycle.NewExecutor(runner, statusReader, statusWriter)
- executor.Execute(ctx, storyKey) returns error
- router.ErrStoryComplete for done stories
- Table-driven TDD tests (see run_test.go TestRunCommand_FullLifecycleExecution)

**Constraining decisions:**

- [Phase 7-02]: Interface-based DI for WorkflowRunner, StatusReader, StatusWriter
- [Phase 8-01]: Changed App fields from concrete types to interfaces
- [Phase 8-01]: Returns router.ErrStoryComplete for done stories (print message, continue)
  </context>

<feature>
  <name>Epic command with lifecycle execution per story</name>
  <files>internal/cli/epic.go, internal/cli/epic_test.go</files>
  <behavior>
    Epic command should:
    1. Get all stories for epic ID (existing GetEpicStories behavior)
    2. For each story in numeric order:
       a. Create lifecycle.Executor with app dependencies
       b. Execute full lifecycle (executor.Execute)
       c. If ErrStoryComplete: print message, continue to next story
       d. If other error: fail fast, return error
    3. Print summary of all stories processed

    Test cases (table-driven like run_test.go):
    - Epic with 2 backlog stories → each runs 4 workflows (create→dev→review→commit)
    - Epic with mixed statuses → each story runs appropriate remaining workflows
    - Epic with done story → done story skipped with message, others run lifecycle
    - Story failure mid-lifecycle → stops, reports which story/workflow failed
    - No stories found → returns error (existing behavior)

  </behavior>
  <implementation>
    1. Replace QueueRunner usage with lifecycle.Executor loop
    2. For each story: create executor, call Execute(), handle errors
    3. Done stories (ErrStoryComplete) should print message and continue (not fail)
    4. Workflow failures should fail fast (stop processing remaining stories)
    5. Update help text to describe full lifecycle behavior
  </implementation>
</feature>

<verification>
```bash
go test -v ./internal/cli/... -run TestEpic
go build ./cmd/bmad-automate
```
</verification>

<success_criteria>

- Failing test written and committed (RED)
- Implementation passes test (GREEN)
- Refactor complete if needed
- All 2-3 commits present
- Epic command runs full lifecycle per story, not single workflow
- Done stories are skipped with message (not failure)
- Fail-fast on workflow failure
  </success_criteria>

<output>
After completion, create `.planning/phases/09-update-epic-command/09-01-SUMMARY.md` with:
- RED: What test was written, why it failed
- GREEN: What implementation made it pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced
</output>
